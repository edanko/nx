// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/edanko/nx/cmd/moses-api/internal/adapters/ent/nest"
	"github.com/edanko/nx/cmd/moses-api/internal/adapters/ent/part"
	"github.com/edanko/nx/cmd/moses-api/internal/adapters/ent/predicate"
	"github.com/edanko/nx/cmd/moses-api/internal/adapters/ent/remnant"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeNest    = "Nest"
	TypePart    = "Part"
	TypeRemnant = "Remnant"
)

// NestMutation represents an operation that mutates the Nest nodes in the graph.
type NestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	length              *float64
	addlength           *float64
	clearedFields       map[string]struct{}
	parts               map[uuid.UUID]struct{}
	removedparts        map[uuid.UUID]struct{}
	clearedparts        bool
	remnant             *uuid.UUID
	clearedremnant      bool
	remnant_used        *uuid.UUID
	clearedremnant_used bool
	done                bool
	oldValue            func(context.Context) (*Nest, error)
	predicates          []predicate.Nest
}

var _ ent.Mutation = (*NestMutation)(nil)

// nestOption allows management of the mutation configuration using functional options.
type nestOption func(*NestMutation)

// newNestMutation creates new mutation for the Nest entity.
func newNestMutation(c config, op Op, opts ...nestOption) *NestMutation {
	m := &NestMutation{
		config:        c,
		op:            op,
		typ:           TypeNest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNestID sets the ID field of the mutation.
func withNestID(id uuid.UUID) nestOption {
	return func(m *NestMutation) {
		var (
			err   error
			once  sync.Once
			value *Nest
		)
		m.oldValue = func(ctx context.Context) (*Nest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNest sets the old Nest of the mutation.
func withNest(node *Nest) nestOption {
	return func(m *NestMutation) {
		m.oldValue = func(context.Context) (*Nest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Nest entities.
func (m *NestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Nest entity.
// If the Nest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Nest entity.
// If the Nest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *NestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Nest entity.
// If the Nest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NestMutation) ResetName() {
	m.name = nil
}

// SetLength sets the "length" field.
func (m *NestMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *NestMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Nest entity.
// If the Nest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NestMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *NestMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *NestMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *NestMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// AddPartIDs adds the "parts" edge to the Part entity by ids.
func (m *NestMutation) AddPartIDs(ids ...uuid.UUID) {
	if m.parts == nil {
		m.parts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.parts[ids[i]] = struct{}{}
	}
}

// ClearParts clears the "parts" edge to the Part entity.
func (m *NestMutation) ClearParts() {
	m.clearedparts = true
}

// PartsCleared reports if the "parts" edge to the Part entity was cleared.
func (m *NestMutation) PartsCleared() bool {
	return m.clearedparts
}

// RemovePartIDs removes the "parts" edge to the Part entity by IDs.
func (m *NestMutation) RemovePartIDs(ids ...uuid.UUID) {
	if m.removedparts == nil {
		m.removedparts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.parts, ids[i])
		m.removedparts[ids[i]] = struct{}{}
	}
}

// RemovedParts returns the removed IDs of the "parts" edge to the Part entity.
func (m *NestMutation) RemovedPartsIDs() (ids []uuid.UUID) {
	for id := range m.removedparts {
		ids = append(ids, id)
	}
	return
}

// PartsIDs returns the "parts" edge IDs in the mutation.
func (m *NestMutation) PartsIDs() (ids []uuid.UUID) {
	for id := range m.parts {
		ids = append(ids, id)
	}
	return
}

// ResetParts resets all changes to the "parts" edge.
func (m *NestMutation) ResetParts() {
	m.parts = nil
	m.clearedparts = false
	m.removedparts = nil
}

// SetRemnantID sets the "remnant" edge to the Remnant entity by id.
func (m *NestMutation) SetRemnantID(id uuid.UUID) {
	m.remnant = &id
}

// ClearRemnant clears the "remnant" edge to the Remnant entity.
func (m *NestMutation) ClearRemnant() {
	m.clearedremnant = true
}

// RemnantCleared reports if the "remnant" edge to the Remnant entity was cleared.
func (m *NestMutation) RemnantCleared() bool {
	return m.clearedremnant
}

// RemnantID returns the "remnant" edge ID in the mutation.
func (m *NestMutation) RemnantID() (id uuid.UUID, exists bool) {
	if m.remnant != nil {
		return *m.remnant, true
	}
	return
}

// RemnantIDs returns the "remnant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RemnantID instead. It exists only for internal usage by the builders.
func (m *NestMutation) RemnantIDs() (ids []uuid.UUID) {
	if id := m.remnant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRemnant resets all changes to the "remnant" edge.
func (m *NestMutation) ResetRemnant() {
	m.remnant = nil
	m.clearedremnant = false
}

// SetRemnantUsedID sets the "remnant_used" edge to the Remnant entity by id.
func (m *NestMutation) SetRemnantUsedID(id uuid.UUID) {
	m.remnant_used = &id
}

// ClearRemnantUsed clears the "remnant_used" edge to the Remnant entity.
func (m *NestMutation) ClearRemnantUsed() {
	m.clearedremnant_used = true
}

// RemnantUsedCleared reports if the "remnant_used" edge to the Remnant entity was cleared.
func (m *NestMutation) RemnantUsedCleared() bool {
	return m.clearedremnant_used
}

// RemnantUsedID returns the "remnant_used" edge ID in the mutation.
func (m *NestMutation) RemnantUsedID() (id uuid.UUID, exists bool) {
	if m.remnant_used != nil {
		return *m.remnant_used, true
	}
	return
}

// RemnantUsedIDs returns the "remnant_used" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RemnantUsedID instead. It exists only for internal usage by the builders.
func (m *NestMutation) RemnantUsedIDs() (ids []uuid.UUID) {
	if id := m.remnant_used; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRemnantUsed resets all changes to the "remnant_used" edge.
func (m *NestMutation) ResetRemnantUsed() {
	m.remnant_used = nil
	m.clearedremnant_used = false
}

// Where appends a list predicates to the NestMutation builder.
func (m *NestMutation) Where(ps ...predicate.Nest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nest).
func (m *NestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NestMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, nest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, nest.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, nest.FieldName)
	}
	if m.length != nil {
		fields = append(fields, nest.FieldLength)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nest.FieldCreatedAt:
		return m.CreatedAt()
	case nest.FieldUpdatedAt:
		return m.UpdatedAt()
	case nest.FieldName:
		return m.Name()
	case nest.FieldLength:
		return m.Length()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case nest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case nest.FieldName:
		return m.OldName(ctx)
	case nest.FieldLength:
		return m.OldLength(ctx)
	}
	return nil, fmt.Errorf("unknown Nest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case nest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case nest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nest.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	}
	return fmt.Errorf("unknown Nest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NestMutation) AddedFields() []string {
	var fields []string
	if m.addlength != nil {
		fields = append(fields, nest.FieldLength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nest.FieldLength:
		return m.AddedLength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nest.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	}
	return fmt.Errorf("unknown Nest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NestMutation) ResetField(name string) error {
	switch name {
	case nest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case nest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case nest.FieldName:
		m.ResetName()
		return nil
	case nest.FieldLength:
		m.ResetLength()
		return nil
	}
	return fmt.Errorf("unknown Nest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parts != nil {
		edges = append(edges, nest.EdgeParts)
	}
	if m.remnant != nil {
		edges = append(edges, nest.EdgeRemnant)
	}
	if m.remnant_used != nil {
		edges = append(edges, nest.EdgeRemnantUsed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nest.EdgeParts:
		ids := make([]ent.Value, 0, len(m.parts))
		for id := range m.parts {
			ids = append(ids, id)
		}
		return ids
	case nest.EdgeRemnant:
		if id := m.remnant; id != nil {
			return []ent.Value{*id}
		}
	case nest.EdgeRemnantUsed:
		if id := m.remnant_used; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedparts != nil {
		edges = append(edges, nest.EdgeParts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nest.EdgeParts:
		ids := make([]ent.Value, 0, len(m.removedparts))
		for id := range m.removedparts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparts {
		edges = append(edges, nest.EdgeParts)
	}
	if m.clearedremnant {
		edges = append(edges, nest.EdgeRemnant)
	}
	if m.clearedremnant_used {
		edges = append(edges, nest.EdgeRemnantUsed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NestMutation) EdgeCleared(name string) bool {
	switch name {
	case nest.EdgeParts:
		return m.clearedparts
	case nest.EdgeRemnant:
		return m.clearedremnant
	case nest.EdgeRemnantUsed:
		return m.clearedremnant_used
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NestMutation) ClearEdge(name string) error {
	switch name {
	case nest.EdgeRemnant:
		m.ClearRemnant()
		return nil
	case nest.EdgeRemnantUsed:
		m.ClearRemnantUsed()
		return nil
	}
	return fmt.Errorf("unknown Nest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NestMutation) ResetEdge(name string) error {
	switch name {
	case nest.EdgeParts:
		m.ResetParts()
		return nil
	case nest.EdgeRemnant:
		m.ResetRemnant()
		return nil
	case nest.EdgeRemnantUsed:
		m.ResetRemnantUsed()
		return nil
	}
	return fmt.Errorf("unknown Nest edge %s", name)
}

// PartMutation represents an operation that mutates the Part nodes in the graph.
type PartMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	project       *string
	section       *string
	pos           *string
	quality       *string
	_type         *string
	length        *float64
	addlength     *float64
	width         *float64
	addwidth      *float64
	thickness     *float64
	addthickness  *float64
	count         *int64
	addcount      *int64
	nested        *int64
	addnested     *int64
	clearedFields map[string]struct{}
	nests         map[uuid.UUID]struct{}
	removednests  map[uuid.UUID]struct{}
	clearednests  bool
	done          bool
	oldValue      func(context.Context) (*Part, error)
	predicates    []predicate.Part
}

var _ ent.Mutation = (*PartMutation)(nil)

// partOption allows management of the mutation configuration using functional options.
type partOption func(*PartMutation)

// newPartMutation creates new mutation for the Part entity.
func newPartMutation(c config, op Op, opts ...partOption) *PartMutation {
	m := &PartMutation{
		config:        c,
		op:            op,
		typ:           TypePart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartID sets the ID field of the mutation.
func withPartID(id uuid.UUID) partOption {
	return func(m *PartMutation) {
		var (
			err   error
			once  sync.Once
			value *Part
		)
		m.oldValue = func(ctx context.Context) (*Part, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Part.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPart sets the old Part of the mutation.
func withPart(node *Part) partOption {
	return func(m *PartMutation) {
		m.oldValue = func(context.Context) (*Part, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Part entities.
func (m *PartMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Part.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProject sets the "project" field.
func (m *PartMutation) SetProject(s string) {
	m.project = &s
}

// Project returns the value of the "project" field in the mutation.
func (m *PartMutation) Project() (r string, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProject returns the old "project" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldProject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProject: %w", err)
	}
	return oldValue.Project, nil
}

// ResetProject resets all changes to the "project" field.
func (m *PartMutation) ResetProject() {
	m.project = nil
}

// SetSection sets the "section" field.
func (m *PartMutation) SetSection(s string) {
	m.section = &s
}

// Section returns the value of the "section" field in the mutation.
func (m *PartMutation) Section() (r string, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSection returns the old "section" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldSection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSection: %w", err)
	}
	return oldValue.Section, nil
}

// ResetSection resets all changes to the "section" field.
func (m *PartMutation) ResetSection() {
	m.section = nil
}

// SetPos sets the "pos" field.
func (m *PartMutation) SetPos(s string) {
	m.pos = &s
}

// Pos returns the value of the "pos" field in the mutation.
func (m *PartMutation) Pos() (r string, exists bool) {
	v := m.pos
	if v == nil {
		return
	}
	return *v, true
}

// OldPos returns the old "pos" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldPos(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPos: %w", err)
	}
	return oldValue.Pos, nil
}

// ResetPos resets all changes to the "pos" field.
func (m *PartMutation) ResetPos() {
	m.pos = nil
}

// SetQuality sets the "quality" field.
func (m *PartMutation) SetQuality(s string) {
	m.quality = &s
}

// Quality returns the value of the "quality" field in the mutation.
func (m *PartMutation) Quality() (r string, exists bool) {
	v := m.quality
	if v == nil {
		return
	}
	return *v, true
}

// OldQuality returns the old "quality" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldQuality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuality: %w", err)
	}
	return oldValue.Quality, nil
}

// ResetQuality resets all changes to the "quality" field.
func (m *PartMutation) ResetQuality() {
	m.quality = nil
}

// SetType sets the "type" field.
func (m *PartMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PartMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PartMutation) ResetType() {
	m._type = nil
}

// SetLength sets the "length" field.
func (m *PartMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *PartMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *PartMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *PartMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *PartMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *PartMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *PartMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *PartMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *PartMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *PartMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetThickness sets the "thickness" field.
func (m *PartMutation) SetThickness(f float64) {
	m.thickness = &f
	m.addthickness = nil
}

// Thickness returns the value of the "thickness" field in the mutation.
func (m *PartMutation) Thickness() (r float64, exists bool) {
	v := m.thickness
	if v == nil {
		return
	}
	return *v, true
}

// OldThickness returns the old "thickness" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldThickness(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThickness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThickness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThickness: %w", err)
	}
	return oldValue.Thickness, nil
}

// AddThickness adds f to the "thickness" field.
func (m *PartMutation) AddThickness(f float64) {
	if m.addthickness != nil {
		*m.addthickness += f
	} else {
		m.addthickness = &f
	}
}

// AddedThickness returns the value that was added to the "thickness" field in this mutation.
func (m *PartMutation) AddedThickness() (r float64, exists bool) {
	v := m.addthickness
	if v == nil {
		return
	}
	return *v, true
}

// ResetThickness resets all changes to the "thickness" field.
func (m *PartMutation) ResetThickness() {
	m.thickness = nil
	m.addthickness = nil
}

// SetCount sets the "count" field.
func (m *PartMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *PartMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *PartMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *PartMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *PartMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetNested sets the "nested" field.
func (m *PartMutation) SetNested(i int64) {
	m.nested = &i
	m.addnested = nil
}

// Nested returns the value of the "nested" field in the mutation.
func (m *PartMutation) Nested() (r int64, exists bool) {
	v := m.nested
	if v == nil {
		return
	}
	return *v, true
}

// OldNested returns the old "nested" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldNested(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNested is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNested requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNested: %w", err)
	}
	return oldValue.Nested, nil
}

// AddNested adds i to the "nested" field.
func (m *PartMutation) AddNested(i int64) {
	if m.addnested != nil {
		*m.addnested += i
	} else {
		m.addnested = &i
	}
}

// AddedNested returns the value that was added to the "nested" field in this mutation.
func (m *PartMutation) AddedNested() (r int64, exists bool) {
	v := m.addnested
	if v == nil {
		return
	}
	return *v, true
}

// ResetNested resets all changes to the "nested" field.
func (m *PartMutation) ResetNested() {
	m.nested = nil
	m.addnested = nil
}

// AddNestIDs adds the "nests" edge to the Nest entity by ids.
func (m *PartMutation) AddNestIDs(ids ...uuid.UUID) {
	if m.nests == nil {
		m.nests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nests[ids[i]] = struct{}{}
	}
}

// ClearNests clears the "nests" edge to the Nest entity.
func (m *PartMutation) ClearNests() {
	m.clearednests = true
}

// NestsCleared reports if the "nests" edge to the Nest entity was cleared.
func (m *PartMutation) NestsCleared() bool {
	return m.clearednests
}

// RemoveNestIDs removes the "nests" edge to the Nest entity by IDs.
func (m *PartMutation) RemoveNestIDs(ids ...uuid.UUID) {
	if m.removednests == nil {
		m.removednests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nests, ids[i])
		m.removednests[ids[i]] = struct{}{}
	}
}

// RemovedNests returns the removed IDs of the "nests" edge to the Nest entity.
func (m *PartMutation) RemovedNestsIDs() (ids []uuid.UUID) {
	for id := range m.removednests {
		ids = append(ids, id)
	}
	return
}

// NestsIDs returns the "nests" edge IDs in the mutation.
func (m *PartMutation) NestsIDs() (ids []uuid.UUID) {
	for id := range m.nests {
		ids = append(ids, id)
	}
	return
}

// ResetNests resets all changes to the "nests" edge.
func (m *PartMutation) ResetNests() {
	m.nests = nil
	m.clearednests = false
	m.removednests = nil
}

// Where appends a list predicates to the PartMutation builder.
func (m *PartMutation) Where(ps ...predicate.Part) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Part).
func (m *PartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, part.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, part.FieldUpdatedAt)
	}
	if m.project != nil {
		fields = append(fields, part.FieldProject)
	}
	if m.section != nil {
		fields = append(fields, part.FieldSection)
	}
	if m.pos != nil {
		fields = append(fields, part.FieldPos)
	}
	if m.quality != nil {
		fields = append(fields, part.FieldQuality)
	}
	if m._type != nil {
		fields = append(fields, part.FieldType)
	}
	if m.length != nil {
		fields = append(fields, part.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, part.FieldWidth)
	}
	if m.thickness != nil {
		fields = append(fields, part.FieldThickness)
	}
	if m.count != nil {
		fields = append(fields, part.FieldCount)
	}
	if m.nested != nil {
		fields = append(fields, part.FieldNested)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case part.FieldCreatedAt:
		return m.CreatedAt()
	case part.FieldUpdatedAt:
		return m.UpdatedAt()
	case part.FieldProject:
		return m.Project()
	case part.FieldSection:
		return m.Section()
	case part.FieldPos:
		return m.Pos()
	case part.FieldQuality:
		return m.Quality()
	case part.FieldType:
		return m.GetType()
	case part.FieldLength:
		return m.Length()
	case part.FieldWidth:
		return m.Width()
	case part.FieldThickness:
		return m.Thickness()
	case part.FieldCount:
		return m.Count()
	case part.FieldNested:
		return m.Nested()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case part.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case part.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case part.FieldProject:
		return m.OldProject(ctx)
	case part.FieldSection:
		return m.OldSection(ctx)
	case part.FieldPos:
		return m.OldPos(ctx)
	case part.FieldQuality:
		return m.OldQuality(ctx)
	case part.FieldType:
		return m.OldType(ctx)
	case part.FieldLength:
		return m.OldLength(ctx)
	case part.FieldWidth:
		return m.OldWidth(ctx)
	case part.FieldThickness:
		return m.OldThickness(ctx)
	case part.FieldCount:
		return m.OldCount(ctx)
	case part.FieldNested:
		return m.OldNested(ctx)
	}
	return nil, fmt.Errorf("unknown Part field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case part.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case part.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case part.FieldProject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProject(v)
		return nil
	case part.FieldSection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSection(v)
		return nil
	case part.FieldPos:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPos(v)
		return nil
	case part.FieldQuality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuality(v)
		return nil
	case part.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case part.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case part.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case part.FieldThickness:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThickness(v)
		return nil
	case part.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case part.FieldNested:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNested(v)
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartMutation) AddedFields() []string {
	var fields []string
	if m.addlength != nil {
		fields = append(fields, part.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, part.FieldWidth)
	}
	if m.addthickness != nil {
		fields = append(fields, part.FieldThickness)
	}
	if m.addcount != nil {
		fields = append(fields, part.FieldCount)
	}
	if m.addnested != nil {
		fields = append(fields, part.FieldNested)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case part.FieldLength:
		return m.AddedLength()
	case part.FieldWidth:
		return m.AddedWidth()
	case part.FieldThickness:
		return m.AddedThickness()
	case part.FieldCount:
		return m.AddedCount()
	case part.FieldNested:
		return m.AddedNested()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartMutation) AddField(name string, value ent.Value) error {
	switch name {
	case part.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case part.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case part.FieldThickness:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThickness(v)
		return nil
	case part.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case part.FieldNested:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNested(v)
		return nil
	}
	return fmt.Errorf("unknown Part numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Part nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartMutation) ResetField(name string) error {
	switch name {
	case part.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case part.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case part.FieldProject:
		m.ResetProject()
		return nil
	case part.FieldSection:
		m.ResetSection()
		return nil
	case part.FieldPos:
		m.ResetPos()
		return nil
	case part.FieldQuality:
		m.ResetQuality()
		return nil
	case part.FieldType:
		m.ResetType()
		return nil
	case part.FieldLength:
		m.ResetLength()
		return nil
	case part.FieldWidth:
		m.ResetWidth()
		return nil
	case part.FieldThickness:
		m.ResetThickness()
		return nil
	case part.FieldCount:
		m.ResetCount()
		return nil
	case part.FieldNested:
		m.ResetNested()
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.nests != nil {
		edges = append(edges, part.EdgeNests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case part.EdgeNests:
		ids := make([]ent.Value, 0, len(m.nests))
		for id := range m.nests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednests != nil {
		edges = append(edges, part.EdgeNests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case part.EdgeNests:
		ids := make([]ent.Value, 0, len(m.removednests))
		for id := range m.removednests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednests {
		edges = append(edges, part.EdgeNests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartMutation) EdgeCleared(name string) bool {
	switch name {
	case part.EdgeNests:
		return m.clearednests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Part unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartMutation) ResetEdge(name string) error {
	switch name {
	case part.EdgeNests:
		m.ResetNests()
		return nil
	}
	return fmt.Errorf("unknown Part edge %s", name)
}

// RemnantMutation represents an operation that mutates the Remnant nodes in the graph.
type RemnantMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	quality             *string
	_type               *string
	length              *float64
	addlength           *float64
	width               *float64
	addwidth            *float64
	thickness           *float64
	addthickness        *float64
	clearedFields       map[string]struct{}
	nest                *uuid.UUID
	clearednest         bool
	remnant_used        map[uuid.UUID]struct{}
	removedremnant_used map[uuid.UUID]struct{}
	clearedremnant_used bool
	done                bool
	oldValue            func(context.Context) (*Remnant, error)
	predicates          []predicate.Remnant
}

var _ ent.Mutation = (*RemnantMutation)(nil)

// remnantOption allows management of the mutation configuration using functional options.
type remnantOption func(*RemnantMutation)

// newRemnantMutation creates new mutation for the Remnant entity.
func newRemnantMutation(c config, op Op, opts ...remnantOption) *RemnantMutation {
	m := &RemnantMutation{
		config:        c,
		op:            op,
		typ:           TypeRemnant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemnantID sets the ID field of the mutation.
func withRemnantID(id uuid.UUID) remnantOption {
	return func(m *RemnantMutation) {
		var (
			err   error
			once  sync.Once
			value *Remnant
		)
		m.oldValue = func(ctx context.Context) (*Remnant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Remnant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemnant sets the old Remnant of the mutation.
func withRemnant(node *Remnant) remnantOption {
	return func(m *RemnantMutation) {
		m.oldValue = func(context.Context) (*Remnant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemnantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemnantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Remnant entities.
func (m *RemnantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemnantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemnantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Remnant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RemnantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RemnantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RemnantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RemnantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RemnantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RemnantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RemnantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RemnantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RemnantMutation) ResetName() {
	m.name = nil
}

// SetQuality sets the "quality" field.
func (m *RemnantMutation) SetQuality(s string) {
	m.quality = &s
}

// Quality returns the value of the "quality" field in the mutation.
func (m *RemnantMutation) Quality() (r string, exists bool) {
	v := m.quality
	if v == nil {
		return
	}
	return *v, true
}

// OldQuality returns the old "quality" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldQuality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuality: %w", err)
	}
	return oldValue.Quality, nil
}

// ResetQuality resets all changes to the "quality" field.
func (m *RemnantMutation) ResetQuality() {
	m.quality = nil
}

// SetType sets the "type" field.
func (m *RemnantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RemnantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RemnantMutation) ResetType() {
	m._type = nil
}

// SetLength sets the "length" field.
func (m *RemnantMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *RemnantMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *RemnantMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *RemnantMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *RemnantMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *RemnantMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *RemnantMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *RemnantMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *RemnantMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *RemnantMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetThickness sets the "thickness" field.
func (m *RemnantMutation) SetThickness(f float64) {
	m.thickness = &f
	m.addthickness = nil
}

// Thickness returns the value of the "thickness" field in the mutation.
func (m *RemnantMutation) Thickness() (r float64, exists bool) {
	v := m.thickness
	if v == nil {
		return
	}
	return *v, true
}

// OldThickness returns the old "thickness" field's value of the Remnant entity.
// If the Remnant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemnantMutation) OldThickness(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThickness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThickness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThickness: %w", err)
	}
	return oldValue.Thickness, nil
}

// AddThickness adds f to the "thickness" field.
func (m *RemnantMutation) AddThickness(f float64) {
	if m.addthickness != nil {
		*m.addthickness += f
	} else {
		m.addthickness = &f
	}
}

// AddedThickness returns the value that was added to the "thickness" field in this mutation.
func (m *RemnantMutation) AddedThickness() (r float64, exists bool) {
	v := m.addthickness
	if v == nil {
		return
	}
	return *v, true
}

// ResetThickness resets all changes to the "thickness" field.
func (m *RemnantMutation) ResetThickness() {
	m.thickness = nil
	m.addthickness = nil
}

// SetNestID sets the "nest" edge to the Nest entity by id.
func (m *RemnantMutation) SetNestID(id uuid.UUID) {
	m.nest = &id
}

// ClearNest clears the "nest" edge to the Nest entity.
func (m *RemnantMutation) ClearNest() {
	m.clearednest = true
}

// NestCleared reports if the "nest" edge to the Nest entity was cleared.
func (m *RemnantMutation) NestCleared() bool {
	return m.clearednest
}

// NestID returns the "nest" edge ID in the mutation.
func (m *RemnantMutation) NestID() (id uuid.UUID, exists bool) {
	if m.nest != nil {
		return *m.nest, true
	}
	return
}

// NestIDs returns the "nest" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NestID instead. It exists only for internal usage by the builders.
func (m *RemnantMutation) NestIDs() (ids []uuid.UUID) {
	if id := m.nest; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNest resets all changes to the "nest" edge.
func (m *RemnantMutation) ResetNest() {
	m.nest = nil
	m.clearednest = false
}

// AddRemnantUsedIDs adds the "remnant_used" edge to the Nest entity by ids.
func (m *RemnantMutation) AddRemnantUsedIDs(ids ...uuid.UUID) {
	if m.remnant_used == nil {
		m.remnant_used = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.remnant_used[ids[i]] = struct{}{}
	}
}

// ClearRemnantUsed clears the "remnant_used" edge to the Nest entity.
func (m *RemnantMutation) ClearRemnantUsed() {
	m.clearedremnant_used = true
}

// RemnantUsedCleared reports if the "remnant_used" edge to the Nest entity was cleared.
func (m *RemnantMutation) RemnantUsedCleared() bool {
	return m.clearedremnant_used
}

// RemoveRemnantUsedIDs removes the "remnant_used" edge to the Nest entity by IDs.
func (m *RemnantMutation) RemoveRemnantUsedIDs(ids ...uuid.UUID) {
	if m.removedremnant_used == nil {
		m.removedremnant_used = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.remnant_used, ids[i])
		m.removedremnant_used[ids[i]] = struct{}{}
	}
}

// RemovedRemnantUsed returns the removed IDs of the "remnant_used" edge to the Nest entity.
func (m *RemnantMutation) RemovedRemnantUsedIDs() (ids []uuid.UUID) {
	for id := range m.removedremnant_used {
		ids = append(ids, id)
	}
	return
}

// RemnantUsedIDs returns the "remnant_used" edge IDs in the mutation.
func (m *RemnantMutation) RemnantUsedIDs() (ids []uuid.UUID) {
	for id := range m.remnant_used {
		ids = append(ids, id)
	}
	return
}

// ResetRemnantUsed resets all changes to the "remnant_used" edge.
func (m *RemnantMutation) ResetRemnantUsed() {
	m.remnant_used = nil
	m.clearedremnant_used = false
	m.removedremnant_used = nil
}

// Where appends a list predicates to the RemnantMutation builder.
func (m *RemnantMutation) Where(ps ...predicate.Remnant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RemnantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Remnant).
func (m *RemnantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemnantMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, remnant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, remnant.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, remnant.FieldName)
	}
	if m.quality != nil {
		fields = append(fields, remnant.FieldQuality)
	}
	if m._type != nil {
		fields = append(fields, remnant.FieldType)
	}
	if m.length != nil {
		fields = append(fields, remnant.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, remnant.FieldWidth)
	}
	if m.thickness != nil {
		fields = append(fields, remnant.FieldThickness)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemnantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remnant.FieldCreatedAt:
		return m.CreatedAt()
	case remnant.FieldUpdatedAt:
		return m.UpdatedAt()
	case remnant.FieldName:
		return m.Name()
	case remnant.FieldQuality:
		return m.Quality()
	case remnant.FieldType:
		return m.GetType()
	case remnant.FieldLength:
		return m.Length()
	case remnant.FieldWidth:
		return m.Width()
	case remnant.FieldThickness:
		return m.Thickness()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemnantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remnant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case remnant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case remnant.FieldName:
		return m.OldName(ctx)
	case remnant.FieldQuality:
		return m.OldQuality(ctx)
	case remnant.FieldType:
		return m.OldType(ctx)
	case remnant.FieldLength:
		return m.OldLength(ctx)
	case remnant.FieldWidth:
		return m.OldWidth(ctx)
	case remnant.FieldThickness:
		return m.OldThickness(ctx)
	}
	return nil, fmt.Errorf("unknown Remnant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemnantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remnant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case remnant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case remnant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case remnant.FieldQuality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuality(v)
		return nil
	case remnant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case remnant.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case remnant.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case remnant.FieldThickness:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThickness(v)
		return nil
	}
	return fmt.Errorf("unknown Remnant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemnantMutation) AddedFields() []string {
	var fields []string
	if m.addlength != nil {
		fields = append(fields, remnant.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, remnant.FieldWidth)
	}
	if m.addthickness != nil {
		fields = append(fields, remnant.FieldThickness)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemnantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case remnant.FieldLength:
		return m.AddedLength()
	case remnant.FieldWidth:
		return m.AddedWidth()
	case remnant.FieldThickness:
		return m.AddedThickness()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemnantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case remnant.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case remnant.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case remnant.FieldThickness:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThickness(v)
		return nil
	}
	return fmt.Errorf("unknown Remnant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemnantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemnantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemnantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Remnant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemnantMutation) ResetField(name string) error {
	switch name {
	case remnant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case remnant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case remnant.FieldName:
		m.ResetName()
		return nil
	case remnant.FieldQuality:
		m.ResetQuality()
		return nil
	case remnant.FieldType:
		m.ResetType()
		return nil
	case remnant.FieldLength:
		m.ResetLength()
		return nil
	case remnant.FieldWidth:
		m.ResetWidth()
		return nil
	case remnant.FieldThickness:
		m.ResetThickness()
		return nil
	}
	return fmt.Errorf("unknown Remnant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemnantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nest != nil {
		edges = append(edges, remnant.EdgeNest)
	}
	if m.remnant_used != nil {
		edges = append(edges, remnant.EdgeRemnantUsed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemnantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case remnant.EdgeNest:
		if id := m.nest; id != nil {
			return []ent.Value{*id}
		}
	case remnant.EdgeRemnantUsed:
		ids := make([]ent.Value, 0, len(m.remnant_used))
		for id := range m.remnant_used {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemnantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedremnant_used != nil {
		edges = append(edges, remnant.EdgeRemnantUsed)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemnantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case remnant.EdgeRemnantUsed:
		ids := make([]ent.Value, 0, len(m.removedremnant_used))
		for id := range m.removedremnant_used {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemnantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednest {
		edges = append(edges, remnant.EdgeNest)
	}
	if m.clearedremnant_used {
		edges = append(edges, remnant.EdgeRemnantUsed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemnantMutation) EdgeCleared(name string) bool {
	switch name {
	case remnant.EdgeNest:
		return m.clearednest
	case remnant.EdgeRemnantUsed:
		return m.clearedremnant_used
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemnantMutation) ClearEdge(name string) error {
	switch name {
	case remnant.EdgeNest:
		m.ClearNest()
		return nil
	}
	return fmt.Errorf("unknown Remnant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemnantMutation) ResetEdge(name string) error {
	switch name {
	case remnant.EdgeNest:
		m.ResetNest()
		return nil
	case remnant.EdgeRemnantUsed:
		m.ResetRemnantUsed()
		return nil
	}
	return fmt.Errorf("unknown Remnant edge %s", name)
}
